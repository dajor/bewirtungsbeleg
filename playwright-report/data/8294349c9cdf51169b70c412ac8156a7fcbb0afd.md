# Test info

- Name: Complete Bewirtungsbeleg Workflow >> should handle OCR extraction and auto-fill form fields
- Location: /Users/daniel/dev/Bewritung/bewir/test/e2e-complete-workflow.spec.ts:156:3

# Error details

```
Error: locator.setInputFiles: Error: strict mode violation: locator('input[type="file"]') resolved to 2 elements:
    1) <input multiple type="file" tabindex="-1" accept="image/png,image/jpeg,image/webp,application/pdf"/> aka getByRole('button', { name: 'Choose File' })
    2) <input type="file" accept=".json"/> aka locator('div').filter({ hasText: /^JSON DownloadJSON Upload$/ }).locator('input[type="file"]')

Call log:
  - waiting for locator('input[type="file"]')

    at BewirtungsbelegWorkflow.uploadReceipt (/Users/daniel/dev/Bewritung/bewir/test/e2e-complete-workflow.spec.ts:21:5)
    at /Users/daniel/dev/Bewritung/bewir/test/e2e-complete-workflow.spec.ts:188:5
```

# Page snapshot

```yaml
- banner:
  - link "DocBits":
    - /url: /
    - img "DocBits"
  - link "Beleg erstellen":
    - /url: /bewirtungsbeleg
  - link "Features":
    - /url: /#features
  - link "GoBD":
    - /url: /gobd
  - link "Release Notes":
    - /url: /release-notes
  - link "Anmelden":
    - /url: /auth/signin
  - link "Registrieren":
    - /url: /auth/register
- main:
  - img "DocBits Logo"
  - heading "Bewirtungsbeleg" [level=1]
  - checkbox "Eigenbeleg (ohne Originalbeleg)"
  - text: Eigenbeleg (ohne Originalbeleg)
  - paragraph: "Aktivieren Sie diese Option, wenn Sie keinen Originalbeleg haben. Hinweis: Bei Eigenbelegen kann die Vorsteuer (MwSt.) nicht geltend gemacht werden."
  - heading "Allgemeine Angaben" [level=2]
  - paragraph: Foto/Scan der Rechnung
  - paragraph: Laden Sie Fotos, Scans oder PDFs hoch - die Daten werden automatisch extrahiert
  - button "Choose File"
  - img
  - paragraph: Dateien hier ablegen
  - paragraph: Bilder (PNG, JPEG, WEBP) oder PDFs, max. 5 Dateien
  - text: Datum der Bewirtung
  - textbox "Datum der Bewirtung"
  - text: Restaurant
  - textbox "Restaurant"
  - text: Anschrift
  - textbox "Anschrift"
  - text: Art der Bewirtung
  - paragraph: Wählen Sie die Art der Bewirtung - dies beeinflusst die steuerliche Abzugsfähigkeit
  - radiogroup "Art der Bewirtung":
    - radio "Kundenbewirtung (70% abzugsfähig)" [checked]
    - text: Kundenbewirtung (70% abzugsfähig)
    - paragraph: Für Geschäftsfreunde (Kunden, Geschäftspartner). 70% der Kosten sind als Betriebsausgabe abziehbar.
    - radio "Mitarbeiterbewirtung (100% abzugsfähig)"
    - text: Mitarbeiterbewirtung (100% abzugsfähig)
    - paragraph: Für betriebliche Veranstaltungen (Teamessen, Arbeitsessen). 100% der Kosten sind als Betriebsausgabe abziehbar.
  - heading "Finanzielle Details" [level=2]
  - checkbox "Ausländische Rechnung (keine MwSt.)"
  - text: Ausländische Rechnung (keine MwSt.)
  - paragraph: Aktivieren Sie diese Option, wenn die Rechnung aus dem Ausland stammt. In diesem Fall wird der Gesamtbetrag als Netto behandelt.
  - separator
  - checkbox "ZUGFeRD-kompatibles PDF generieren"
  - text: ZUGFeRD-kompatibles PDF generieren
  - paragraph: Erstellt ein elektronisches Rechnungsformat nach ZUGFeRD 2.0 Standard für die digitale Archivierung
  - text: Gesamtbetrag (Brutto)
  - paragraph: Geben Sie den Gesamtbetrag der Rechnung ein (inkl. MwSt.)
  - textbox "Gesamtbetrag (Brutto)"
  - text: MwSt. Gesamtbetrag
  - paragraph: MwSt. (19%) wird automatisch berechnet
  - textbox "MwSt. Gesamtbetrag"
  - text: Netto Gesamtbetrag
  - paragraph: Netto wird automatisch berechnet
  - textbox "Netto Gesamtbetrag"
  - text: Betrag auf Kreditkarte/Bar
  - paragraph: Geben Sie den Betrag ein, der auf der Kreditkarte belastet wurde (inkl. Trinkgeld)
  - textbox "Betrag auf Kreditkarte/Bar"
  - text: Trinkgeld
  - paragraph: Geben Sie das Trinkgeld ein. Dies wird automatisch berechnet, wenn Sie den Betrag auf der Kreditkarte eingeben
  - textbox "Trinkgeld"
  - text: MwSt. Trinkgeld
  - paragraph: MwSt. (19%) wird automatisch berechnet
  - textbox "MwSt. Trinkgeld"
  - text: Zahlungsart
  - paragraph: Wählen Sie die Art der Zahlung. Die Rechnung muss auf die Firma ausgestellt sein.
  - textbox "Zahlungsart": Firmenkreditkarte
  - img
  - heading "Geschäftlicher Anlass" [level=2]
  - text: Geschäftlicher Anlass
  - paragraph: Geben Sie den konkreten Anlass an (z.B. 'Kundengespräch', 'Projektbesprechung')
  - textbox "Geschäftlicher Anlass"
  - text: Namen aller Teilnehmer
  - paragraph: Geben Sie die Namen aller Teilnehmer ein (auch Ihren eigenen Namen)
  - textbox "Namen aller Teilnehmer"
  - text: Namen der Geschäftspartner
  - paragraph: Geben Sie die Namen der Geschäftspartner ein
  - textbox "Namen der Geschäftspartner"
  - text: Firma der Geschäftspartner
  - paragraph: Geben Sie die Firma der Geschäftspartner ein
  - textbox "Firma der Geschäftspartner"
  - button "JSON Download":
    - img
    - text: JSON Download
  - img
  - button "JSON Upload"
  - button "Bewirtungsbeleg erstellen"
  - button "In GoBD-Tresor speichern"
- alert
```

# Test source

```ts
   1 | /**
   2 |  * E2E Test 1: Complete workflow (Upload→OCR→Edit→PDF)
   3 |  * Tests the entire user journey from receipt upload to PDF generation
   4 |  */
   5 |
   6 | import { test, expect, Page } from '@playwright/test';
   7 | import * as path from 'path';
   8 | import * as fs from 'fs';
   9 |
   10 | // Page Object Model for complete workflow
   11 | class BewirtungsbelegWorkflow {
   12 |   constructor(private page: Page) {}
   13 |
   14 |   async navigate() {
   15 |     await this.page.goto('/bewirtungsbeleg');
   16 |     await this.page.waitForLoadState('networkidle');
   17 |   }
   18 |
   19 |   async uploadReceipt(filePath: string) {
   20 |     const fileInput = this.page.locator('input[type="file"]');
>  21 |     await fileInput.setInputFiles(filePath);
      |     ^ Error: locator.setInputFiles: Error: strict mode violation: locator('input[type="file"]') resolved to 2 elements:
   22 |     await this.page.waitForTimeout(1000);
   23 |   }
   24 |
   25 |   async clickExtractData() {
   26 |     const extractButton = this.page.locator('button:has-text("Daten extrahieren")');
   27 |     await extractButton.click();
   28 |   }
   29 |
   30 |   async waitForOCRCompletion() {
   31 |     // Wait for loading spinner to appear and disappear
   32 |     await this.page.waitForSelector('[role="progressbar"]', { state: 'visible', timeout: 5000 });
   33 |     await this.page.waitForSelector('[role="progressbar"]', { state: 'hidden', timeout: 30000 });
   34 |   }
   35 |
   36 |   async fillFormField(fieldName: string, value: string) {
   37 |     const field = this.page.locator(`input[name="${fieldName}"], textarea[name="${fieldName}"]`);
   38 |     await field.clear();
   39 |     await field.fill(value);
   40 |   }
   41 |
   42 |   async selectDropdown(fieldName: string, value: string) {
   43 |     const dropdown = this.page.locator(`select[name="${fieldName}"]`);
   44 |     await dropdown.selectOption(value);
   45 |   }
   46 |
   47 |   async setDate(fieldName: string, date: string) {
   48 |     // German date format DD.MM.YYYY
   49 |     const dateInput = this.page.locator(`input[name="${fieldName}"]`);
   50 |     await dateInput.clear();
   51 |     await dateInput.fill(date);
   52 |   }
   53 |
   54 |   async clickGeneratePDF() {
   55 |     const generateButton = this.page.locator('button:has-text("PDF generieren")');
   56 |     await generateButton.click();
   57 |   }
   58 |
   59 |   async waitForPDFGeneration() {
   60 |     // Wait for success message or PDF download
   61 |     await this.page.waitForSelector('[role="alert"]:has-text("erfolgreich")', { timeout: 10000 });
   62 |   }
   63 |
   64 |   async getFormValue(fieldName: string): Promise<string> {
   65 |     const field = this.page.locator(`input[name="${fieldName}"], textarea[name="${fieldName}"]`);
   66 |     return await field.inputValue();
   67 |   }
   68 |
   69 |   async hasError(): Promise<boolean> {
   70 |     const errorAlert = this.page.locator('[role="alert"][data-type="error"]');
   71 |     return await errorAlert.isVisible();
   72 |   }
   73 |
   74 |   async getErrorMessage(): Promise<string | null> {
   75 |     const errorAlert = this.page.locator('[role="alert"][data-type="error"]');
   76 |     if (await errorAlert.isVisible()) {
   77 |       return await errorAlert.textContent();
   78 |     }
   79 |     return null;
   80 |   }
   81 | }
   82 |
   83 | test.describe('Complete Bewirtungsbeleg Workflow', () => {
   84 |   let workflow: BewirtungsbelegWorkflow;
   85 |
   86 |   test.beforeEach(async ({ page }) => {
   87 |     workflow = new BewirtungsbelegWorkflow(page);
   88 |     await workflow.navigate();
   89 |   });
   90 |
   91 |   test('should complete full workflow from image upload to PDF generation', async ({ page }) => {
   92 |     // Step 1: Upload receipt image
   93 |     const testImagePath = path.join(process.cwd(), 'test', 'test-receipt.png');
   94 |     
   95 |     // Create a simple test image if it doesn't exist
   96 |     if (!fs.existsSync(testImagePath)) {
   97 |       // Create a minimal PNG file
   98 |       const pngBuffer = Buffer.from([
   99 |         0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A,
  100 |         0x00, 0x00, 0x00, 0x0D, 0x49, 0x48, 0x44, 0x52,
  101 |         0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
  102 |         0x08, 0x02, 0x00, 0x00, 0x00, 0x90, 0x77, 0x53,
  103 |         0xDE, 0x00, 0x00, 0x00, 0x0C, 0x49, 0x44, 0x41,
  104 |         0x54, 0x08, 0x99, 0x63, 0xF8, 0xCF, 0xC0, 0x00,
  105 |         0x00, 0x00, 0x03, 0x00, 0x01, 0x5E, 0xF9, 0x51,
  106 |         0x36, 0x00, 0x00, 0x00, 0x00, 0x49, 0x45, 0x4E,
  107 |         0x44, 0xAE, 0x42, 0x60, 0x82
  108 |       ]);
  109 |       fs.writeFileSync(testImagePath, pngBuffer);
  110 |     }
  111 |
  112 |     await workflow.uploadReceipt(testImagePath);
  113 |
  114 |     // Step 2: Extract data with OCR (mock or real)
  115 |     // Check if extract button is available
  116 |     const extractButton = page.locator('button:has-text("Daten extrahieren")');
  117 |     if (await extractButton.isVisible()) {
  118 |       await workflow.clickExtractData();
  119 |       
  120 |       // Wait for OCR to complete (or mock response)
  121 |       try {
```