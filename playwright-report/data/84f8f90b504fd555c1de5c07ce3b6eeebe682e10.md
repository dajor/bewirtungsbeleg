# Test info

- Name: E2E Test 2: Multiple File Handling with Ordering >> should allow file removal and re-upload
- Location: /Users/daniel/dev/Bewritung/bewir/test/e2e-critical-scenarios.spec.ts:170:3

# Error details

```
Error: expect(received).toBeGreaterThan(expected)

Expected: > 0
Received:   0
    at /Users/daniel/dev/Bewritung/bewir/test/e2e-critical-scenarios.spec.ts:179:26
```

# Page snapshot

```yaml
- img "DocBits Logo"
- heading "Bewirtungsbeleg" [level=1]
- checkbox "Eigenbeleg (ohne Originalbeleg)"
- text: Eigenbeleg (ohne Originalbeleg)
- paragraph: "Aktivieren Sie diese Option, wenn Sie keinen Originalbeleg haben. Hinweis: Bei Eigenbelegen kann die Vorsteuer (MwSt.) nicht geltend gemacht werden."
- heading "Allgemeine Angaben" [level=2]
- paragraph: Foto/Scan der Rechnung
- paragraph: Laden Sie Fotos, Scans oder PDFs hoch - die Daten werden automatisch extrahiert
- button "Choose File"
- img
- paragraph: Dateien hier ablegen
- paragraph: Bilder (PNG, JPEG, WEBP) oder PDFs, max. 5 Dateien
- paragraph: Hochgeladene Dateien (1/5)
- paragraph: Konvertiere PDF...
- img
- paragraph: PDF
- paragraph: removable.pdf
- text: Unbekannt 0.0 KB
- textbox "Klassifizierung": Unbekannt
- img
- button "Konvertierung abbrechen":
  - img
- text: Datum der Bewirtung
- textbox "Datum der Bewirtung"
- text: Restaurant
- textbox "Restaurant"
- button "Restaurant suchen":
  - img
- text: Anschrift
- textbox "Anschrift"
- text: Art der Bewirtung
- paragraph: Wählen Sie die Art der Bewirtung - dies beeinflusst die steuerliche Abzugsfähigkeit
- radiogroup "Art der Bewirtung":
  - radio "Kundenbewirtung (70% abzugsfähig)" [checked]
  - text: Kundenbewirtung (70% abzugsfähig)
  - paragraph: Für Geschäftsfreunde (Kunden, Geschäftspartner). 70% der Kosten sind als Betriebsausgabe abziehbar.
  - radio "Mitarbeiterbewirtung (100% abzugsfähig)"
  - text: Mitarbeiterbewirtung (100% abzugsfähig)
  - paragraph: Für betriebliche Veranstaltungen (Teamessen, Arbeitsessen). 100% der Kosten sind als Betriebsausgabe abziehbar.
- heading "Finanzielle Details" [level=2]
- checkbox "Ausländische Rechnung (keine MwSt.)"
- text: Ausländische Rechnung (keine MwSt.)
- paragraph: Aktivieren Sie diese Option, wenn die Rechnung aus dem Ausland stammt. In diesem Fall wird der Gesamtbetrag als Netto behandelt.
- separator
- checkbox "ZUGFeRD-kompatibles PDF generieren"
- text: ZUGFeRD-kompatibles PDF generieren
- paragraph: Erstellt ein elektronisches Rechnungsformat nach ZUGFeRD 2.0 Standard für die digitale Archivierung
- text: Gesamtbetrag (Brutto)
- paragraph: Geben Sie den Gesamtbetrag der Rechnung ein (inkl. MwSt.)
- textbox "Gesamtbetrag (Brutto)"
- text: MwSt. Gesamtbetrag
- paragraph: MwSt. (19%) wird automatisch berechnet
- textbox "MwSt. Gesamtbetrag"
- text: Netto Gesamtbetrag
- paragraph: Netto wird automatisch berechnet
- textbox "Netto Gesamtbetrag"
- text: Betrag auf Kreditkarte/Bar
- paragraph: Geben Sie den Betrag ein, der auf der Kreditkarte belastet wurde (inkl. Trinkgeld)
- textbox "Betrag auf Kreditkarte/Bar"
- text: Trinkgeld
- paragraph: Geben Sie das Trinkgeld ein. Dies wird automatisch berechnet, wenn Sie den Betrag auf der Kreditkarte eingeben
- textbox "Trinkgeld"
- text: MwSt. Trinkgeld
- paragraph: MwSt. (19%) wird automatisch berechnet
- textbox "MwSt. Trinkgeld"
- text: Zahlungsart
- paragraph: Wählen Sie die Art der Zahlung. Die Rechnung muss auf die Firma ausgestellt sein.
- textbox "Zahlungsart": Firmenkreditkarte
- img
- heading "Geschäftlicher Anlass" [level=2]
- text: Geschäftlicher Anlass
- paragraph: Geben Sie den konkreten Anlass an (z.B. 'Kundengespräch', 'Projektbesprechung')
- textbox "Geschäftlicher Anlass"
- text: Namen aller Teilnehmer
- paragraph: Geben Sie die Namen aller Teilnehmer ein (auch Ihren eigenen Namen)
- textbox "Namen aller Teilnehmer"
- text: Namen der Geschäftspartner
- paragraph: Geben Sie die Namen der Geschäftspartner ein
- textbox "Namen der Geschäftspartner"
- text: Firma der Geschäftspartner
- paragraph: Geben Sie die Firma der Geschäftspartner ein
- textbox "Firma der Geschäftspartner"
- button "JSON Download":
  - img
  - text: JSON Download
- img
- button "JSON Upload"
- button "Bewirtungsbeleg erstellen"
- paragraph: Image Editor
- alert:
  - img
  - text: Failed to convert PDF. Please try with an image file.
  - button:
    - img
- img
- paragraph: No preview available
- paragraph: Rotation Controls
- button [disabled]:
  - img
- button [disabled]:
  - img
- button [disabled]:
  - img
- button [disabled]:
  - img
- button "Apply Rotation" [disabled]
- alert
```

# Test source

```ts
   79 |     return null;
   80 |   }
   81 |
   82 |   async isFieldValid(fieldName: string): Promise<boolean> {
   83 |     const field = this.page.locator(`input[name="${fieldName}"]`);
   84 |     const isInvalid = await field.getAttribute('aria-invalid');
   85 |     return isInvalid !== 'true';
   86 |   }
   87 |
   88 |   async waitForLoading() {
   89 |     await this.page.waitForSelector('[role="progressbar"]', { state: 'visible', timeout: 5000 });
   90 |     await this.page.waitForSelector('[role="progressbar"]', { state: 'hidden', timeout: 30000 });
   91 |   }
   92 |
   93 |   async toggleForeignReceipt() {
   94 |     const checkbox = this.page.locator('input[name="istAuslaendischeRechnung"]');
   95 |     await checkbox.click();
   96 |   }
   97 |
   98 |   async fillMinimalValidForm() {
   99 |     await this.fillField('restaurantName', 'Test Restaurant');
  100 |     await this.fillField('datum', '06.08.2025');
  101 |     await this.fillField('teilnehmer', 'Test Person');
  102 |     await this.fillField('anlass', 'Test Anlass');
  103 |     await this.fillField('gesamtbetrag', '100,00');
  104 |     await this.selectOption('zahlungsart', 'firma');
  105 |     await this.selectOption('bewirtungsart', 'mitarbeiter');
  106 |   }
  107 | }
  108 |
  109 | test.describe('E2E Test 2: Multiple File Handling with Ordering', () => {
  110 |   let page: BewirtungsbelegPage;
  111 |
  112 |   test.beforeEach(async ({ page: playwrightPage }) => {
  113 |     page = new BewirtungsbelegPage(playwrightPage);
  114 |     await page.navigate();
  115 |   });
  116 |
  117 |   test('should maintain correct file order: Rechnung before Kreditbeleg', async () => {
  118 |     // Create test files
  119 |     const rechnungPath = path.join(process.cwd(), 'test', 'test-rechnung.pdf');
  120 |     const kreditbelegPath = path.join(process.cwd(), 'test', 'test-kreditbeleg.pdf');
  121 |     
  122 |     if (!fs.existsSync(rechnungPath)) {
  123 |       fs.writeFileSync(rechnungPath, 'Rechnung PDF content');
  124 |     }
  125 |     if (!fs.existsSync(kreditbelegPath)) {
  126 |       fs.writeFileSync(kreditbelegPath, 'Kreditbeleg PDF content');
  127 |     }
  128 |
  129 |     // Upload in wrong order
  130 |     await page.uploadFiles([kreditbelegPath, rechnungPath]);
  131 |
  132 |     // Fill minimal form
  133 |     await page.fillMinimalValidForm();
  134 |
  135 |     // Generate PDF
  136 |     await page.clickButton('PDF generieren');
  137 |
  138 |     // The system should automatically reorder attachments
  139 |     // Rechnung should come before Kreditbeleg in the final PDF
  140 |     // This is a business rule for German tax compliance
  141 |     
  142 |     const errors = await page.getErrorMessages();
  143 |     expect(errors.length).toBe(0);
  144 |   });
  145 |
  146 |   test('should handle multiple attachments of same type', async () => {
  147 |     const files: string[] = [];
  148 |     
  149 |     // Create multiple test files
  150 |     for (let i = 1; i <= 3; i++) {
  151 |       const filePath = path.join(process.cwd(), 'test', `rechnung-${i}.pdf`);
  152 |       if (!fs.existsSync(filePath)) {
  153 |         fs.writeFileSync(filePath, `Rechnung ${i} content`);
  154 |       }
  155 |       files.push(filePath);
  156 |     }
  157 |
  158 |     await page.uploadFiles(files);
  159 |     
  160 |     const uploadedFiles = await page.getUploadedFileNames();
  161 |     expect(uploadedFiles.length).toBeGreaterThanOrEqual(3);
  162 |
  163 |     await page.fillMinimalValidForm();
  164 |     await page.clickButton('PDF generieren');
  165 |
  166 |     const errors = await page.getErrorMessages();
  167 |     expect(errors.length).toBe(0);
  168 |   });
  169 |
  170 |   test('should allow file removal and re-upload', async () => {
  171 |     const filePath = path.join(process.cwd(), 'test', 'removable.pdf');
  172 |     if (!fs.existsSync(filePath)) {
  173 |       fs.writeFileSync(filePath, 'Test content');
  174 |     }
  175 |
  176 |     // Upload file
  177 |     await page.uploadFiles([filePath]);
  178 |     let files = await page.getUploadedFileNames();
> 179 |     expect(files.length).toBeGreaterThan(0);
      |                          ^ Error: expect(received).toBeGreaterThan(expected)
  180 |
  181 |     // Remove file
  182 |     await page.removeFile(0);
  183 |     await page.page.waitForTimeout(500);
  184 |
  185 |     // Re-upload
  186 |     await page.uploadFiles([filePath]);
  187 |     files = await page.getUploadedFileNames();
  188 |     expect(files.length).toBeGreaterThan(0);
  189 |   });
  190 | });
  191 |
  192 | test.describe('E2E Test 3: Error Recovery and Retry', () => {
  193 |   let page: BewirtungsbelegPage;
  194 |
  195 |   test.beforeEach(async ({ page: playwrightPage }) => {
  196 |     page = new BewirtungsbelegPage(playwrightPage);
  197 |     await page.navigate();
  198 |   });
  199 |
  200 |   test('should recover from OCR API failure', async ({ page: playwrightPage }) => {
  201 |     // Mock OCR failure
  202 |     let attemptCount = 0;
  203 |     await playwrightPage.route('**/api/extract-receipt', route => {
  204 |       attemptCount++;
  205 |       if (attemptCount === 1) {
  206 |         // First attempt fails
  207 |         route.fulfill({
  208 |           status: 503,
  209 |           body: JSON.stringify({ error: 'Service temporarily unavailable' })
  210 |         });
  211 |       } else {
  212 |         // Second attempt succeeds
  213 |         route.fulfill({
  214 |           status: 200,
  215 |           body: JSON.stringify({
  216 |             restaurantName: 'Recovered Restaurant',
  217 |             gesamtbetrag: '100,00'
  218 |           })
  219 |         });
  220 |       }
  221 |     });
  222 |
  223 |     const testImage = path.join(process.cwd(), 'test', 'test.png');
  224 |     if (!fs.existsSync(testImage)) {
  225 |       fs.writeFileSync(testImage, Buffer.from([
  226 |         0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A,
  227 |         0x00, 0x00, 0x00, 0x0D, 0x49, 0x48, 0x44, 0x52,
  228 |         0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
  229 |         0x08, 0x02, 0x00, 0x00, 0x00, 0x90, 0x77, 0x53,
  230 |         0xDE
  231 |       ]));
  232 |     }
  233 |
  234 |     await page.uploadFiles([testImage]);
  235 |     
  236 |     // First extraction attempt - should fail
  237 |     await page.clickButton('Daten extrahieren');
  238 |     await playwrightPage.waitForTimeout(2000);
  239 |
  240 |     // Should show error
  241 |     let errors = await page.getErrorMessages();
  242 |     expect(errors.length).toBeGreaterThan(0);
  243 |
  244 |     // Retry - should succeed
  245 |     await page.clickButton('Daten extrahieren');
  246 |     await page.waitForLoading();
  247 |
  248 |     // Check if data was extracted
  249 |     const restaurantName = await playwrightPage.locator('input[name="restaurantName"]').inputValue();
  250 |     expect(restaurantName).toBe('Recovered Restaurant');
  251 |   });
  252 |
  253 |   test('should handle network timeout gracefully', async ({ page: playwrightPage }) => {
  254 |     // Mock network timeout
  255 |     await playwrightPage.route('**/api/generate-pdf', route => {
  256 |       // Delay response to simulate timeout
  257 |       setTimeout(() => {
  258 |         route.fulfill({
  259 |           status: 408,
  260 |           body: JSON.stringify({ error: 'Request timeout' })
  261 |         });
  262 |       }, 5000);
  263 |     });
  264 |
  265 |     await page.fillMinimalValidForm();
  266 |     await page.clickButton('PDF generieren');
  267 |
  268 |     // Should show timeout error
  269 |     const errors = await page.getErrorMessages();
  270 |     expect(errors.some(e => e.toLowerCase().includes('timeout') || e.toLowerCase().includes('zeit'))).toBeTruthy();
  271 |   });
  272 |
  273 |   test('should clear errors when fixing invalid input', async () => {
  274 |     // Submit with invalid data
  275 |     await page.fillField('gesamtbetrag', '100.00'); // Wrong format (dot instead of comma)
  276 |     await page.clickButton('PDF generieren');
  277 |
  278 |     // Should show validation error
  279 |     let errors = await page.getErrorMessages();
```